public include dos_rescue.e

include std/error.e
include std/graphics.e as graphics
include std/machine.e
include std/map.e
include std/text.e

include xlib.e
with trace
atom 
	display    = -1,
	rootwindow = -1,
	window     = -1,
	screen     = -1,
	pixmap     = -1,
	font       = -1

integer mouse_handler_rid = -1

export procedure set_mouse_handler( integer rid )
	mouse_handler_rid = rid
end procedure

map graphics_context = map:new()
map allocated_color  = map:new()

type boolean(integer x)
    return x = TRUE or x = FALSE
end type


public boolean freeze_the_game
freeze_the_game = FALSE

public integer window_exists
window_exists = FALSE

sequence char_buff
char_buff = {}

public integer ShellExecute

atom screen_size_x, screen_size_y   -- current screen size

atom ps, rect
ps = allocate(64)
rect = allocate(16) 

public integer PlaySound, Sleep, Beep

public integer last_text_color
last_text_color = WHITE
public integer last_bk_color
last_bk_color = BLACK

function scale( integer color )
	return floor( (color / 0x100 ) * 0x10000 ) + color
end function

function make_color(integer red, integer green, integer blue)
    -- return blue*65536 + green*256 + red
--     return blue*#10000 + green*#100 + red
	return { scale( red ), scale( green ), scale( blue ) }
end function

function make_color_s(sequence s)
-- 	s = s * {#1_0000,#100,1}
-- 	return s[1] + s[2] + s[3]
	return make_color( s[1], s[2], s[3] )
end function

sequence color_map
color_map = repeat(0, 2049)
--                             RED, GREEN, BLUE 0-255
color_map[1+BLACK] = make_color(1, 1, 1)
color_map[1+BLUE] = make_color(40, 40, 140) 
color_map[1+GREEN] = make_color(0, 128, 0)
color_map[1+CYAN] = make_color(0, 128, 128)
color_map[1+RED] = make_color(128, 0, 0)
color_map[1+MAGENTA] = make_color(128, 0, 128)
color_map[1+BROWN] = make_color(128, 128, 0)
color_map[1+WHITE] = make_color(192, 192, 192)
color_map[1+GRAY] = make_color(64, 64, 64)
color_map[1+BRIGHT_BLUE] = make_color(90, 90, 255)
color_map[1+BRIGHT_GREEN] = make_color(0,255,0)
color_map[1+BRIGHT_CYAN] = make_color(0, 255, 255)
color_map[1+BRIGHT_RED] = make_color(255, 0, 0)
color_map[1+BRIGHT_MAGENTA] = make_color(255, 0, 255)
color_map[1+YELLOW] = make_color(255, 255, 0)
color_map[1+BRIGHT_WHITE] = make_color(255, 255, 255)

function get_color( integer color )
	sequence mapped_color = color_map[color + 1]
	atom c = map:get( allocated_color, mapped_color, 0 )
	if not c then
		c = alloc_color( display, mapped_color[1], mapped_color[2], mapped_color[3], 1 )
		map:put( allocated_color, mapped_color, c )
	end if
	return c
end function

function get_gc( integer fore_color = last_text_color, integer bk_color = last_bk_color)
	atom 
		bk   = get_color( bk_color ),
		fore = get_color( fore_color )
	
	atom gc = map:get( graphics_context, { bk, fore }, 0 )
	if not gc then
		-- need to create one!
		atom gcv = new_GCValue( 1 )
		set_GC_value( gcv, GCBackground, peek_pointer( bk ) )
		set_GC_value( gcv, GCForeground, peek_pointer( fore ) )
		gc = XCreateGC( display, pixmap, GCBackground + GCForeground, gcv )
		map:put( graphics_context, { bk, fore }, gc )
	end if
	return gc
end function


for i = 1 to 1025 by 16 do
    color_map[i+16..i+31] = color_map[i..i+15]
end for

public procedure set_color(integer color)
-- all foreground color changes come through here
    last_text_color = color
end procedure

public procedure set_bk_color(integer color)
-- all background color changes come through here
    last_bk_color = color
end procedure

public procedure text_color(integer color)
-- was calling routine in graphics.e to set text color
-- text or graphics modes - not really needed
    if not window_exists then
        graphics:text_color(color)
    else
        last_text_color = color
    end if
end procedure

public procedure clear_region(integer x1, integer y1, integer x2, integer y2)
	polygon( last_bk_color, 1, { {x1, y1}, {x2, y1}, {x2, y2}, {x1, y2} } )
end procedure

integer cursor_line, cursor_column
cursor_line = 1 cursor_column = 1

public procedure clear_screen()
-- -- override Euphoria built-in 
    if not window_exists then
        eu:clear_screen()
    else
        -- pos = {0,0}
        cursor_column = 1
        cursor_line = 1
        clear_region(0, 0, screen_size_x, screen_size_y)
    end if
end procedure

public procedure bk_color(integer color)
-- was calling routine in graphics.e to set background color
-- text or graphics modes - not really needed
    if not window_exists then
        graphics:bk_color(color)
    else
        last_bk_color = color
        clear_screen()
    end if
end procedure


public integer repaint
repaint = -1
integer abort_program
abort_program = 0

sequence map_key
map_key = repeat(-1,#10000)
-- map_key[16] = 16 -- shift
-- map_key[17] = 17 -- ctrl
map_key[33] = 329 -- page-up
map_key[34] = 337 -- page-down
map_key[35] = 335 -- end
map_key[36] = 327 -- home
map_key[37] = 331 -- left
map_key[38] = 328 -- up
map_key[39] = 333 -- right
map_key[40] = 336 -- down
map_key[45] = 338 -- insert
map_key[46] = 339 -- delete
map_key[112] = 315 -- F1
map_key[113] = 316 -- F2
map_key[114] = 317 -- F3
map_key[115] = 318 -- F4
map_key[116] = 319 -- F5
map_key[117] = 320 -- F6
map_key[118] = 321 -- F7
map_key[119] = 322 -- F8
map_key[120] = 323 -- F9
-- map_key[121] = 324 -- F10
map_key[122] = 389 -- F11
map_key[123] = 390 -- F12

procedure blit()
	XCopyArea( 
		display, 
		pixmap, 
		window, 
		get_gc(), 
		0, 
		0, 
		screen_size_x, 
		screen_size_y,
		0,
		0)
end procedure

atom
	wm_protocols,
	wm_destroy

procedure main( integer first_time )
	if first_time then
		-- create the window
		display = XOpenDisplay( 0 )
		screen  = DefaultScreen( display )
		rootwindow = RootWindow( display, screen )
		screen_size_x = video_modes[video_mode+1][VC_XPIXELS]
		screen_size_y = video_modes[video_mode+1][VC_YPIXELS]
		window = XCreateSimpleWindow( display, rootwindow, 100, 100, 
			screen_size_x + 2, 
			screen_size_y + 2, 
			2, last_bk_color, 0xCCCCCC )
		
		wm_protocols = XInternAtom(display, "WM_PROTOCOLS", 0)
		wm_destroy = XInternAtom( display, "WM_DELETE_WINDOW", 0)
		XSetWMProtocols( display, window, wm_destroy )
		XMapWindow( display, window )
		window_exists = 1
		
		pixmap = XCreatePixmap( display, window, 
			screen_size_x, 
			screen_size_y, 
			XDefaultDepth( display, screen ) )
		
		atom default_gcontext = XGContextFromGC( XDefaultGC( display, screen ) )
-- 		atom fontstruct = XQueryFont( display, default_gcontext )
-- 		font = peek_pointer( fontstruct + XFontStruct_fid )
-- 		? -1 & default_gcontext & font
-- 		fond = default_ccontext
		clear_screen()
		
		XSelectInput( display, window, ExposureMask + KeyPressMask + PointerMotionMask + ButtonPressMask + ButtonReleaseMask )
	end if
	
	atom event = new_XEvent( 1 )
	while 1 do
		if XPending( display ) then
			XNextEvent( display, event )
			integer event_type = peek4s( event )
			switch event_type do
				case ClientMessage then
					atom message_type = peek_pointer( event + XClientMessageEvent_message_type )
					if message_type = wm_protocols then
						if wm_destroy = peek_pointer( event + XClientMessageEvent_data_l ) then
							XDestroyWindow( display, window )
							XCloseDisplay( display )
							abort( 0 )
						end if
					end if
					
				case Expose, GraphicsExpose then
					blit()
				
				case KeyPress then
					integer keysym = XLookupKeysym( event )
					if keysym then
						integer mapped_sym = symmap[keysym]
						if mapped_sym then
							keysym = mapped_sym
						elsif keysym >= 'a' and keysym <= 'z' then
							integer state = peek4s( event + XKeyEvent_state )
							if and_bits( ShiftMask, state ) then
								if not and_bits( LockMask, state ) then
									keysym += 'A' - 'a'
								end if
							elsif and_bits( LockMask, state ) then
								keysym += 'A' - 'a'
							end if
						end if
					end if
					char_buff &= keysym
				
				case ButtonPress, ButtonRelease, MotionNotify then
					if mouse_handler_rid != -1 then
						call_proc( mouse_handler_rid, { event, event_type } )
					end if
			end switch
		else
			if first_time then
				-- create task to check message queue
				atom mq = task_create(routine_id("main"), {FALSE})
				-- check the queue every .2 to .3 seconds
				-- (main program must do a task_yield periodically
				-- or the window will be frozen)
				task_schedule(mq, {.08, .12}) -- make keyboard very responsive
				-- assume hdc has now been set
				return
			end if
            
			if freeze_the_game then
				sleep( 0.001 ) -- sleep n * .001 seconds 
				task_clock_stop()
				if length(char_buff) then
					freeze_the_game = FALSE
					char_buff = char_buff[2..$] -- delete the char
					task_clock_start()
					task_yield()
				end if
			else
				task_yield()
			end if
			
		end if
	end while
end procedure

------------------------------------------------------------------------------------------------------

public function graphics_mode(integer m)
	integer ncolors
	if m = -1 then
		video_mode = m
		XDestroyWindow( display, window )
	elsif sequence(video_modes[m+1]) then
		video_mode = m
		ncolors = video_modes[m+1][VC_NCOLORS]
		if ncolors > 2048 then
			-- must expand color_map or change the implementation
			-- for more than 2048 colors. (or use Direct X or Open GL)
			crash("Unsupported number of colors %d.", ncolors)
		end if
		if window_exists then
			-- TODO: free GCs
			XDestroyWindow( display, window )
		end if
		main(TRUE) -- initial setup of hdc
	end if
	return 0
end function

------------------------------------------------------------------------------------------------------

-- public procedure all_palette(sequence s)
-- 	if length(s) != video_modes[video_mode+1][VC_NCOLORS] then
-- 		crash("The length of s(=%d) to all_palette doesn't match color depth(=%d).", 
-- 		{length(s), video_modes[video_mode+1][VC_NCOLORS]})
-- 	end if
-- 	for i = 1 to length(s) do
-- 		c_proc(DeleteObject, {brushes[i]})
-- 		c_proc(DeleteObject, {pens[i]})
-- 		color_map[i] = make_color_s(s[i]*4)
-- 		brushes[i] = c_func(CreateSolidBrush, {color_map[i]})
-- 		pens[i] = c_func(CreatePen, {PS_SOLID, 1, color_map[i]})
-- 	end for
-- end procedure

public function get_all_palette()
	integer ncolors = video_modes[video_mode+1][VC_NCOLORS]
	sequence s = color_map[1..ncolors]
	for i = 1 to length(s) do
		s[i] = floor(or_bits(s[i],{#FF0000,#FF00,#FF })/{#40000,#400,#4 } ) 
	end for
	return s
end function

public function palette(integer color_index, sequence new_color_triple)
	sequence old_color = 
	floor(or_bits(color_map[color_index+1],{#FF0000,#FF00,#FF })/{#40000,#400,#4 } )
	color_map[color_index+1] = make_color_s(new_color_triple*4)
	return old_color
end function
	
	

-- public procedure simplepixel(object c, sequence s)
--    integer xstart, y
--    
--    if atom(c) then
--        -- inlined for speed
--        c_proc(SetPixelV, {hdc, s[1], s[2], color_map[1+c]})
--    else
--        y = s[2]
--        xstart = s[1]
--        for i = 1 to length(c) do
--            c_proc(SetPixelV, {hdc, xstart, y, color_map[1+c[i]]})
--            xstart += 1
--        end for  
--    end if
-- end procedure


public procedure pixel(object c, sequence s)
-- -- override Euphoria built-in 
    integer i, xstart, y, pcount, color
	if not window_exists then
		-- eu:pixel(c,s)
	else
		s = floor( s )
		if atom(c) then
			-- single pixel
			XDrawPoint( display, pixmap, get_gc( c ), s[1], s[2] )
		
		else
			-- several pixels on one row
			y = s[2]
			xstart = s[1]
			i = 1
			while i <= length(c) do
				pcount = 1
				color = c[i]
				-- how many in a row are the same color?
				while i + pcount <= length(c) and c[i+pcount] = color do
					pcount += 1
				end while
				if pcount >= 2 then
					XDrawLine( display, pixmap, get_gc( color ), { {xstart, y}, {xstart + pcount, y}})
					i += pcount
				else
					-- do one pixel
					XDrawPoint( display, pixmap, get_gc( color ), xstart, y )
					i += 1
				end if
				xstart += pcount
			end while  
		end if
		blit()
	end if
end procedure


-- public function get_pixel(sequence s)
-- -- override Euphoria built-in 
--     sequence p
--     integer xstart, y
--     
--     if length(s)<2 or length(s)>3 then
--         crash("get_pixel must be supplied a sequence of length 2 or 3.")
--     elsif length(s) = 2 then
--         return c_func(GetPixel, {hdc, s[1], s[2]})
--     else
--         p = repeat(0, s[3])
--         y = s[2]
--         xstart = s[1]
--         for i = 1 to s[3] do
--             p[i] = c_func(GetPixel, {hdc, xstart, y}) 
--             xstart += 1
--         end for
--         return p
--     end if
-- end function

public procedure ellipse(integer color, integer fill, sequence coord1, sequence coord2)
-- atom points, npoints
-- points = 0
-- npoints = 0 integer fill, sequence coord1, sequence coord2)
	if not window_exists then	
-- 		graphics:ellipse(color,fill,coord1,coord2)
	else
		coord2 += 1
		if not color then
			color = last_bk_color
		end if
		atom gc = get_gc( color )
		coord1 = floor( coord1 )
		coord2 = floor( coord2 )
		if fill then
			XFillArc( display, pixmap, gc, coord1[1], coord1[2], coord2[1], coord2[2], 0, 360 * 64 )
		else
			XDrawArc( display, pixmap, gc, coord1[1], coord1[2], coord2[1], coord2[2], 0, 360 * 64 )
		end if
		blit()
	end if
end procedure

public procedure draw_line(integer c, sequence xyarray)
	atom gc = get_gc( c )
	XDrawLine( display, pixmap, gc, floor( xyarray ) )
	blit()
end procedure

public procedure polygon(integer c, integer fill, sequence xyarray)
	if not window_exists then
		--graphics:polygon(c,fill,xyarray)
	else
		atom gc
		gc = get_gc( c )
		
		if fill then
			XFillPolygon( display, pixmap, gc, xyarray )
		else
			XDrawPolygon( display, pixmap, gc, xyarray )
		end if
		blit()
	end if
end procedure

------------------------------------------------------------------------------------------------------


public function get_key()
-- override Euphoria built-in
-- get next character sent to graphics window
    integer c
    if not window_exists then
        return eu:get_key()
    else
        task_yield()
        if length(char_buff) = 0 then
            return -1
        else
            c = char_buff[1]
            char_buff = char_buff[2..$]
            return c
        end if
    end if
end function

public function wait_key()
    integer c
    c = -1
    while c = -1 do
        c = get_key()
    end while
    return c
end function

public procedure pass_key(integer key)
-- emulate key-press
    char_buff &= key
end procedure

atom charRect
charRect = allocate(4*4)
constant CHARLEFT = 0, CHAR_TOP = 4, CHAR_RIGHT = 8, CHAR_BOTTOM = 12
constant DT_SINGLE_LINE = #00000020
constant OPAQUE = 2

public procedure putsxy(sequence pos, sequence string, 
						integer fcolor, integer bcolor)
	XDrawImageString( display, pixmap, get_gc( fcolor, bcolor ), pos[1], pos[2], string )
	blit()
end procedure

public procedure position(integer line, integer column)
-- override Euphoria built-in 
    if not window_exists then
        eu:position(line,column)
    else
        cursor_line = line
        cursor_column = column
        -- pos = (column-1)*8 & (line-1)*16
    end if
end procedure

public function get_position()
    return cursor_line & cursor_column
    -- return floor(pos[Y]/16)+1 & floor(pos[X]/8)+1
end function

public procedure puts(integer fn, object str)
-- -- override Euphoria built-in 
    sequence pos
    integer i,j
    if not window_exists or fn != STDOUT then
        eu:puts(fn,str)
    else
        if atom(str) then
            str = {str}
        end if
        i = 1
        if str[1] = '\n' then
            i += 1
            -- pos[X] = 0
            cursor_column = 1
            -- pos[Y] += 16
            cursor_line += 1
        end if
        while i<=length(str) do
            j = find_from('\n',str,i)
            if j = 0 then
                j = length(str)+1
            end if
            pos = (cursor_column-1)*8 & (cursor_line-1)*16
            putsxy(pos,str[i..j-1],last_text_color,last_bk_color)
            --putsxy({(cursor_column-1)*8,()},str[i..j-1],last_text_color,last_bk_color)
            -- pos[X] += (j-i)*8
            cursor_column += j-i
            if j>length(str) then
                exit
            end if
            cursor_column = 1
            -- pos[X] = 0
            cursor_line += 1
            -- pos[Y] += 16
            i = j+1
        end while
    end if
end procedure

public procedure printf(integer fn, sequence format, object x)
-- override Euphoria built-in 
    sequence s
    if not window_exists or fn != STDOUT then
        eu:printf(fn,format,x)
    else
        s = sprintf(format, x)
        puts(fn,s)
    end if
end procedure

public procedure print(integer fn, object x)
-- override Euphoria built-in 
    sequence s
    if not window_exists or fn != STDOUT then
        eu:print(fn,x)
    else
        s = sprint(x)
        puts(fn,s)
    end if
end procedure

------------------------------------------------------------------------------------------------------

sequence getc_buffer
getc_buffer = {}

public function gets(integer fn)
-- override Euphoria built-in 
    sequence p
    integer k
    sequence buf
    integer len,size
    
    if not window_exists or fn != STDIN then
        return eu:gets(fn)
    elsif length(getc_buffer) then
        buf = getc_buffer
        getc_buffer = {}
        return buf
    else
        buf = {}
        len = 0
        size = 0
        
        p = get_position()
        while 1 do
            puts(1,'_')
            position(p[1],p[2])
            k = wait_key()
            if k = '\r' then
                puts(1,' ')
                position(p[1],p[2])
                exit
            elsif k = 8 and len>0 then
                position(p[1],p[2])
                puts(1,' ')
                -- if p[2]>1 then
                    -- p[2] -= 1
                -- elsif p[1]>1 then
                    -- p[1] -= 1
                    -- p[2] = 80
                -- end if
                -- -- ? p
                p[2] -= 1
                position(p[1],p[2])
                puts(1,'_')
                position(p[1],p[2])
                len -= 1
            elsif k >= ' ' and k < 256 then
                -- position(p[1],p[2])
                puts(1,k)
                p[2] += 1
                -- if p[2] >= 80 then
                    -- p[2]=0
                    -- p[1]+=1
                -- end if
                if len = size then
                    buf &= k
                    len += 1
                    size += 1
                else
                    len += 1
                    buf[len] = k
                end if
            end if
        end while
        
        if len<size then
            buf = buf[1..len]
        end if
        
        return buf & '\r'
    end if
end function

public function getc(integer fn)
-- override Euphoria built-in 
    integer c
    if not window_exists or fn != STDIN then
        return eu:getc(fn)
    elsif length(getc_buffer) = 0 then
        getc_buffer = gets(fn)
    end if
    
    c = getc_buffer[1]
    getc_buffer = getc_buffer[2..$]
    return c
end function

------------------------------------------------------------------------------------------------------

public procedure sound(integer freq)
	-- TODO: ??
--     c_proc(Beep,{freq,50})
end procedure

public procedure use_vesa(integer i)
    ifdef DOS32 then
        machine:use_vesa(i)
    end ifdef
    -- do nothing
end procedure

